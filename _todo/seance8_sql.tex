%!TEX encoding =  IsoLatin
\input{../../common/exo_begin.tex}%
\firstpassagedo{\refstepcounter{cxtd}\refstepcounter{cxtd}\refstepcounter{cxtd}\refstepcounter{cxtd}\refstepcounter{cxtd}\refstepcounter{cxtd}\refstepcounter{cxtd}}



\begin{xtd}{SQL}{seance8_2013_sql_cor}\label{seance8_2013_sql}



\partietdVU{SQL}{index}

Le langage SQL est utilisé pour manipuler des bases de données\footnote{voir \httpstyle{http://fr.wikipedia.org/wiki/Base\_de\_donn\%C3\%A9es}}. Pour faire simple, on utilise les bases de données quand on ne peut plus se servir d'Excel~:
\begin{itemize}
\item le tableau dont on se sert est trop grand (comme trier 50000 lignes)
\item on souhaite faire des opérations sur deux feuilles Excel (associer les lignes de l'une avec celles de l'autre)
\end{itemize}

Lorsque le volume de données est important, il est impossible de les voir dans leur ensemble. On peut en voir soit une partie soit une aggrégation. Par exemple, la société qui gère les vélib a ouvert l'accès à ses données. Il est possible de télécharger aussi souvent qu'on veut (toutes les minutes par exemple) un état complet des vélos et places disponibles pour toutes les stations de Paris~: c'est une table qui s'enrichit de 1300 lignes toutes les minutes.


\partietda{Récupérer les données et premier SELECT}

Ce TD nécessite les données suivantes~:

%%% obtenir les données %%%
\begin{verbatimx}
from pyensae import download_data
download_data("SQLiteSpy.zip", website = 'xd')  # 2 secondes
download_data("td8_velib.zip", website = 'xd')  # 22 secondes (~7 Mo)
\end{verbatimx}

Après l'exécution de ce programme, vous devriez voir à côté de votre programme~:
\begin{enumerate}
\item \codes{SQLiteSpy.exe}~: un programme qui permet d'explorer les bases de données SQLite.
\item \codes{td8\_velib.txt}~: les données de ce TD.
\end{enumerate}

Ensuite, on convertit les données au format texte en base de données au format SQLite~:

%%% obtenir les données %%%
\begin{verbatimx}
from pyensae import import_flatfile_into_database
dbf = "td8_velib.db3"
import_flatfile_into_database(dbf, "td8_velib.txt")                   # 2 secondes 
import_flatfile_into_database(dbf, "stations.txt", table="stations")  # 2 minutes
\end{verbatimx}

Vous devriez voir un fichier \codes{td8\_velib.db3} que vous pouvez ouvrir avec \codes{SQLiteSpy.exe} (voir figure~\ref{td8_snapshot}). Si ces étapes ne fonctionnent pas, vous pouvez directement obtenir le résultat en exécutant~:

%%% obtenir les données (2) %%%
\begin{verbatimx}
from pyensae import download_data
download_data("td8_velib.db3.zip", website = 'xd')  # 40 secondes (~12 Mo)
\end{verbatimx}


\begin{figure}[ht]
\begin{center}\begin{tabular}{|c|}\hline 
\includegraphics[width=10cm]{../python_td_2013/image/td8_spy.png} \\ \hline
\end{tabular}
\end{center}
\caption{Copie d'écran du logiciel SQLiteSpy.exe avec les données du TD.}
\label{td8_snapshot}
\end{figure}

Lire une partie des données~:

%%% SELECT ... WHERE %%%
\begin{verbatimx}
-- sélectionner les données sur une plage horaire donnée
SELECT * FROM td8_velib WHERE last_update >= '2013-09-13 10:00:00' AND last_update <= '2013-09-13 11:00:00'

-- sélectionner certaines colonnes et ordonner les valeurs
SELECT available_bike_stands, available_bikes FROM td8_velib 
WHERE last_update >= '2013-09-13 10:00:00' AND last_update <= '2013-09-13 11:00:00'
ORDER BY available_bike_stands DESC ;

-- compter le nombre d'emplacements de chaque station
SELECT last_update, available_bike_stands + available_bikes AS place, number FROM td8_velib 
WHERE last_update >= '2013-09-13 10:00:00' AND last_update <= '2013-09-13 11:00:00'
ORDER BY place DESC ;
\end{verbatimx}

SELECT, MIN, MAX :

%%% SELECT ... MIN, MAX %%%
\begin{verbatimx}
-- maximum de vélos disponibles sur toutes la base
SELECT MAX(available_bike_stands) FROM td8_velib

-- minimum, maximum de vélos disponibles sur toutes la base
SELECT MIN(available_bike_stands) FROM td8_velib 
UNION ALL 
SELECT MAX(available_bike_stands) FROM td8_velib 

-- ajouter des informations
SELECT "min" AS label, MIN(available_bike_stands) FROM td8_velib 
UNION ALL 
SELECT "max" AS label, MAX(available_bike_stands) FROM td8_velib 
\end{verbatimx}

SELECT, DISTINCT, COUNT, FROM :

%%% SELECT DISTINCT COUNT FROM %%%
\begin{verbatimx}
-- tous les numéros de stations de façon unique
SELECT DISTINCT number FROM td8_velib

-- compter le nombre de stations (1230)
SELECT COUNT(*) FROM (
    SELECT DISTINCT number FROM td8_velib
)
\end{verbatimx}

\textbf{Exercice 1}

\begin{enumerate}
\item Déterminer le nombre de valeur distinctes pour la colonne \codes{last\_update}.
\item Déterminer la première et dernière date.
\end{enumerate}





\partietdb{GROUP BY}

L'instruction \codes{GROUP BY} permet d'aggréger des valeurs (min, max, sum) sur un ensemble de ligne partageant le même ensemble de valeurs (ou clé).


%%% nombre de vélo par date %%%
\begin{verbatimx}
SELECT last_update, SUM(available_bikes) AS velo_disponible
FROM td8_velib
GROUP BY last_update
ORDER BY last_update
\end{verbatimx}

Le résultat est un tableau avec de petites valeurs au début et de grandes vers la fin. Cela est dû au processus de création de la base de données\footnote{Certaines stations sont hors service et la dernière arrivée ou le dernier départ remonte à plusieurs jours. A chaque fois qu'on récupère les données velib, on dispose pour chaque station de la dernière arrivée ou du dernier départ de vélo. Le champ \textit{last\_update} correspond à cette date.}. Il ne faudra considérer que les dates au-delà de 2013-09-10 11:30:19.

\begin{center}\begin{tabular}{l|l} 
last\_update	& velo\_disponible \\ \hline
...&...\\
\texttt{2013-09-10 11:00:19}	&74\\
\texttt{2013-09-10 11:05:19}	&74\\
\texttt{2013-09-10 11:10:19}	&74\\
\texttt{2013-09-10 11:15:19}	&118\\
\texttt{2013-09-10 11:20:19}	&2495\\
\texttt{2013-09-10 11:25:19}	&8809\\
\texttt{2013-09-10 11:30:19}	&12813\\
\texttt{2013-09-10 11:35:19}	&12817\\
\texttt{2013-09-10 11:40:19}	&12744 \\
...&...
\end{tabular} \end{center}





Que fait la requête suivante~? Que se passe-t-il si vous enlevez les symboles "\codes{--}" (on \textit{décommente} la condition \codes{WHERE}).

%%% GROUP BY, COUNT, DISTINCT %%%
\begin{verbatimx}
SELECT last_update, SUM(available_bikes) AS velo_disponible, COUNT(DISTINCT number) AS stations
FROM td8_velib
--WHERE last_update >= "2013-09-10 11:30:19"
GROUP BY last_update
ORDER BY last_update
\end{verbatimx}

Et celle-ci~?

%%% deux clés %%%
\begin{verbatimx}
SELECT last_update, 
       CASE  WHEN available_bikes>0 THEN 1 ELSE 0 END AS vide, 
       COUNT(*) AS nb 
FROM td8_velib
WHERE last_update >= "2013-09-10 11:30:19"
GROUP BY last_update, vide
ORDER BY last_update
\end{verbatimx}

\textbf{Exercice 2 :}

Pour chaque station, compter le nombre de plages horaires de cinq minutes où il n'y a aucun vélo disponible.

\textbf{Exercice 3 :}

Si on note $X(s)$ le nombre de plages horaires de cinq minutes où il n'y a aucun vélo disponible, construire le tableau suivant~: $ k \rightarrow \#\acc{ s | X(s) = k }$.




\partietdc{JOIN}


L'instruction \codes{JOIN} sert à associer des lignes d'une table avec les lignes d'une autre table à partir du moment où elles partagent une information commune.


%%% intersection entre deux tables %%%
\begin{verbatimx}
SELECT A.*, B.name  -- ajout du nom au bout de chaque ligne
FROM td8_velib AS A
JOIN stations AS B
ON A.number == B.number
\end{verbatimx}

On peut s'en servir pour calculer un ratio en associant les deux instructions \codes{GROUP \; BY} et \codes{JOIN}. L'instruction suivante permet d'obtenir la distribution des vélos disponibles sur la période d'étude pour chaque station.

%%% distribution temporelle %%%
\begin{verbatimx}
SELECT A.*, 1.0 * A.available_bikes / B.nb_velo  AS distribution_temporelle
FROM td8_velib AS A
JOIN (
  SELECT number, SUM(available_bikes) AS nb_velo
  FROM td8_velib
	WHERE last_update >= "2013-09-10 11:30:19"
  GROUP BY number
) AS B
ON A.number == B.number
WHERE A.last_update >= "2013-09-10 11:30:19"
\end{verbatimx}


\textbf{Exercice 4 :}

Pour chaque station, déterminer la distribution du nombre de vélos disponibles pour chaque période horaire d'une journée (par station, il y aura donc 24 * 12 valeurs comprises entre 0 et 1.) Le résultat que vous devriez obtenir est illustré par la figure~\ref{td8_dis_hor}.

\begin{figure}[ht]
\begin{center}\begin{tabular}{|c|}\hline 
\includegraphics[width=12cm]{../python_td_2013/image/tb8_dis_hor.png} \\ \hline
\end{tabular}
\end{center}
\caption{Distribution horaire du nombre de vélos pour 4 stations.}
\label{td8_dis_hor}
\end{figure}




\partietdd{Zones de travail et zones de résidences}

On souhaite déterminer si une station se situe plutôt dans une zone de travail ou plutôt dans une zone de résidence. On part de l'hypothèse que, dans une zone de travail, les gens arrivent en vélib et repartent en vélib. C'est sans doute le cas de la station 8003 (voir figure~\ref{td8_dis_hor}). Les vélos seront plutôt disponibles dans la journée. A l'opposé, dans une zone de résidence, les vélos seront disponibles plutôt la nuit. Comment faire à partir de la distribution des vélos disponibles construite à la question précédente~?

On considère que la plage diurne s'étend de 10h à 16h. Vous trouverez une illustration du résultat dans cet article \httpstyle{http://www.xavierdupre.fr/blog/2013-09-26\_nojs.html}.




\partietdEND

On repart de la requête précédente pour effectuer un JOIN avec la table \textit{stations} pour récupérer les coordonnées (lat, long). Après un copier/coller dans Excel, on peut situer les zones de travail sur la région parisienne. 

\partietdCOMMENT

Pour récupérer les données d'une base de données de type sqlite3 depuis \python, il suffit d'utiliser le module \codes{sqlite3}\footnote{\httpstyle{http://docs.python.org/2/library/sqlite3.html\#module-sqlite3}}. Le court exemple suivant permet de récupérer dans \pythons le résultat d'une requête SQL~:


%%% lire des données depuis une base de données SQLite3 %%%
\begin{verbatimx}
import sqlite3
conn = sqlite3.connect(dbf)  # on ouvre une connexion sur la base de données
data = conn.execute("SELECT * FROM stations")  #on exécute une requête SQL
for d in data :    # on affiche le résultat
    print (d)      #  
conn.close()       # on ferme la connexion
\end{verbatimx}





\end{xtd}




\input{../../common/exo_end.tex}%
